""" Tweak metaclasses, classes that generates classes. """


# category: class creation


def prepare():
    """ mcs.__prepare__: Generate the default attributes of a class. """

    class Meta(type):
        @staticmethod
        def __prepare__(class_name, bases):
            return {'value': "attribute added in namespace"}

    class ItemClass(int, metaclass=Meta):
        pass

    return ItemClass.value


def new():
    """ mcs.__new__: Create a class as an instance. """

    class Meta(type):
        def __new__(mcs, class_name, bases, namespace, **_):
            bases = tuple([type(...)] + list(bases))
            cls = type.__new__(mcs, class_name, bases, namespace)
            return cls

        def __prepare__(class_name, bases, **_):
            return {}

        def __init__(cls, class_name, bases, namespace, some_argument=None):
            cls.some_attribute = some_argument

    class ItemClass(int, metaclass=Meta, some_argument=...):
        pass

    return "modified baseclasses are [{}]".format(
        ', '.join(base.__name__ for base in ItemClass.__bases__))


def init():
    """ mcs.__init__: Create a class as an instance. """

    class Meta(type):
        def __init__(cls, class_name, bases, namespace):
            super().__init__(class_name, bases, namespace)
            cls.value = "fullname is {}.{}[{}]".format(
                namespace['__module__'], class_name, ', '.join(
                    base.__name__ for base in bases))

    class ItemClass(int, metaclass=Meta):
        pass

    return ItemClass.value


# category: produced class members


def class_method():
    """ cls.meth(): Class method defined by metaclass. """

    class Meta(type):
        def get_value(cls):
            return "method inherited by {}".format(cls.__name__)

    class ItemClass(metaclass=Meta):
        pass

    return ItemClass.get_value()


def operator():
    """ +, *, -, ...: Operation on classes. """

    class Meta(type):
        def __mul__(cls, other):
            if other is cls:

                class Couple:
                    def __init__(self, value_x, value_y):
                        self.value_x = value_x
                        self.value_y = value_y

                return Couple

    class ItemClass(metaclass=Meta):
        pass

    x = ItemClass()
    y = ItemClass()
    couple = (type(x) * type(y))(x, y)
    return "produced class is {}".format(couple.__class__.__name__)


# category: metaclass class alternatives


def method():
    """ class Cls(metaclass=func): Using a callable as a metaclass. """

    def function(name, bases, namespace, **kw):
        cls = type(name, bases, namespace)
        cls.some_attribute = kw['some_argument']
        cls.value = "generated by meta-method"
        return cls

    class ItemClass(metaclass=function, some_argument=...):
        pass

    return ItemClass.value


def decorator():
    """ @func: Using a class decorator instead. """

    def function(cls):
        cls.value = "modified by the decorator"
        return cls

    @function
    class ItemClass:
        pass

    return ItemClass.value

